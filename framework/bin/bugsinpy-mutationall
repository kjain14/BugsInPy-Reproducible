#!/bin/bash

### bugsinpy-mutateall performs mutation testing on all projects and buggy versions
# This script is adapted to use conda environments, similar to the bugsinpy-testall script.
# It targets the fixed version of buggy files for mutation testing against the entire test suite.

dir_of_script=$(dirname $0)
bugsinpy_location=$(realpath $dir_of_script/../..)
temp_projects="$bugsinpy_location/temp/projects"
index_name="bugsinpy-index.csv"
index_file="$bugsinpy_location/projects/$index_name"

usage="
       -h
             show this help
       -c
             cleanup temp directory
       -p
             specify multiple project:start:end or project:end or project:
             Ex;
             pandas:75:100 (run mutation tests for bugs 75 to 100 in pandas)
             black:5 ansible: (run mutation tests for bug 5 in black and all bugs in ansible)
"

case $1 in
 -[h?] | --help)
    echo "Usage: ${0##*/} [ --help ]"
    echo "$usage"
    exit 0;;
 -c)
    rm -rf "$temp_projects"
    exit 0;;
 -p)
    projects="${@:2}";;
esac

mkdir -p $temp_projects

if ! echo $projects | grep -q ":"; then
  projects=$(ls $bugsinpy_location/projects | grep -v $index_name)
fi

if [ ! -f $index_file ]; then
  echo "repo,bugid,version,result" > $index_file
fi

# Iterate over the projects
for project_name in $projects; do

  # Extract start, finish, and project name
  if echo $projects | grep -q ":"; then
    start=$(echo $project_name | cut -d ":" -f 2)
    finish=$(echo $project_name | cut -d ":" -f 3)
    project=$(echo $project_name | cut -d ":" -f 1)
    if [[ "$start" == "" ]]; then
      finish=$(ls $bugsinpy_location/projects/$project/bugs | wc -l)
      start=1
    elif [[ "$finish" == "" ]]; then
      finish=$start
    fi
  else
    start=1
    finish=$(ls $bugsinpy_location/projects/$project_name/bugs | wc -l)
  fi

  work_dir="$temp_projects/$project"

  # For each bug, run mutation testing
  for bug in $(seq $start $finish); do

    bug_source_dir="$bugsinpy_location/projects/$project/bugs/$bug"

    if [ -d "$bug_source_dir" ]; then

      bug_info="$work_dir/bugsinpy_bug.info"

      # Generate unique hash for the current environment
      bug_python_version=$(grep -o "3\..\.." $bug_info)
      conda_env_name=$(cat <(echo $bug_python_version) "$bug_source_dir/requirements.txt" | md5sum | cut -d' ' -f 1)

      # Setup Conda environment
      . /opt/conda/etc/profile.d/conda.sh
      if ! conda env list | grep -q "$conda_env_name"; then
        conda create -n $conda_env_name -y python=$bug_python_version &>> $work_dir/logs.txt
      fi

      conda activate $conda_env_name

      # Install dependencies (if any)
      pip install -r $bug_source_dir/requirements.txt &>> $work_dir/logs.txt
      pip install mutpy &>> $work_dir/logs.txt

      # Run mutation testing on the fixed version of the buggy file with the entire test suite
      cd $bug_source_dir

      # Assuming $bug_source_dir contains a path to the fixed version of the buggy file and the test suite
      target_module=$(grep "fixed file:" $bug_info | cut -d":" -f2 | xargs) # Extract target module from bug info
      tests_dir=$(find . -name "*_test.py" | xargs) # Assuming tests are identifiable by _test.py suffix

      mutation_output="$work_dir/mutation_${project}_bug${bug}.txt"
      mutpy -t $target_module -u $tests_dir -a &> $mutation_output

      # Check mutation test output and log results
      if grep -q "error" $mutation_output; then
        echo "$project,$bug,error" | tee -a $index_file
      else
        echo "$project,$bug,done" | tee -a $index_file
      fi
    fi
  done
done
